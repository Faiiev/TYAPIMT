# Теория языков программирования и методов трансляции

**Грамматикой называется четверка `G = (N, Σ, P, S)` (1.1), где:**  
1. `N` – конечное множество нетерминальных символов, или нетерминалов (вспомогательных символов);
2. `Σ` – не пересекающееся с `N` конечное множество терминальных символов (или терминалов);
3. `P` – множество правил (или продукций) грамматики;
4. `S` – выделенный символ из `N`, называемый начальным (или исходным).

**Рассмотрим язык арифметических выражений, составленных из целых беззнаковых чисел, скобок и операций сложения, вычитания, умножения и деления.**  
> *Примеры таких выражений:*  
> 23+3  
> 11*(3-6)+28  
> 56/(12+3-23)  

**Грамматика, порождающая язык арифметических выражений, описанный выше (А-язык), определяется следующим образом:**  
`G = (N, Σ, P, Expr)`, где:  
`N = {Expr, Term, Factor, Number}`  
`Σ = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '*', '/', '(', ')', '#'}`  

**Множество правил P, представленных в форме Бэкуса-Наура:**  
`Expr → Term {('+'|'-') Term}'#'` (1.2)  
`Term → Factor {('*'|'/') Factor}` (1.3)  
`Factor → Number| '('Expr')'` (1.4)  
`Number → '0'|'1'|…|'9'|'0'Number|'1'Number|…|'9'Number` (1.5)  
> *Замечание:*  
> 1. Запись вида `{α}` означает итерацию цепочки `α`, т.е. в порождаемой цепочке в этом месте может находиться либо `ε` (пустая цепочка), либо `α`, либо `αα`, либо `ααα` и т.д.
> 2. Запись вида `[ α | β ]` означает, что в порождаемой цепочке в этом месте может находиться либо `α`, либо `β`.
> 3. Символ `#` является вспомогательным и служит для обозначения конца цепочки, указывая тем самым лексическому анализатору о необходимости останова.

## Лабораторная работа №1. Построение лексического анализатора для языка арифметических выражений

**Первой фазой процесса компиляции является лексический анализ.**  
Работа лексического анализатора состоит в том, чтобы сгруппировать определенные терминальные символы в единые синтаксические объекты, называемые лексемами.  
Какие объекты считать лексемами, зависит от определения языка программирования.  
Под лексемой будем подразумевать пару (тип лексемы, индекс в таблице).  
Также в функции лексического анализатора входит удаление комментариев, ненужных пробелов, символов табуляции и т.п.

Применительно к А-языку выделяются два типа лексем: ограничители и числа.  
К ограничителям относятся знаки арифметических операций `+, -, *, /`, а также открывающая и закрывающая скобки `( )`.  
Поле *индекс в таблице* содержит индекс данного символа в таблице символов, соответствующей данному типу лексемы.  


## Лабораторная работа №2. Построение интерпретатора для языка арифметических выражений

**Следующим этапом процесса компиляции после лексического анализа является синтаксический анализ.**  
На этом этапе необходимо установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка, и зафиксировать эту структуру.  
Следовательно, необходимо снова решить задачу разбора: дана цепочка лексем и нужно определить, выводима ли она в грамматике, определяющей синтаксис языка.  
Однако, структура таких конструкций, как арифметические выражения, более сложная, нежели структура числовых констант и ограничителей.

Синтаксис А-языка задан с помощью правил грамматики, его порождающей (1.2 – 1.5).  
Причем правило (1.5) на данном этапе можно отбросить, поскольку числовые константы уже выделены в отдельные лексемы.

Существуют табличные методы синтаксического анализа, применимые ко всему классу контекстно-свободных грамматик и требующие для разбора цепочек длины `n` времени `cn^3` (алгоритм Кока-Янгера-Касами) либо `cn^2` (алгоритм Эрли).  
Их разумно применять только в том случае, если для интересующего нас языка не существует грамматики, по которой можно построить анализатор с линейной временной зависимостью.  
Алгоритмы анализа, расходующие на обработку входной цепочки линейное время, применимы только к некоторым подклассам контекстно-свободных грамматик.  
Одним из таких алгоритмов является метод рекурсивного спуска, который применим к т.н. LL(1)-грамматикам.

> *LL(1)- грамматикой называется контекстно-свободная грамматика, каждое правило которой имеет вид:*  
> 1. либо `A → α`, где `α Є (Σ U N)*` и это единственное правило вывода для этого нетерминала;
> 2. либо `A → a1α1 | a2α2 | ... | anαn`, где  
> `ai Є Σ` для всех `i = 1, 2, …, n`;  
> `ai ≠ aj` для `i ≠ j`;  
> `αi Є (Σ U N)*`, т. е. если для нетерминала `А` правил вывода несколько, то они должны начинаться с терминалов, причем все эти терминалы должны быть различными.

Правила (1.2 – 1.4) подходят под определение LL(1)-грамматики, следовательно для построения синтаксического анализатора А-языка мы можем воспользоваться методом рекурсивного спуска.

> *Метод рекурсивного спуска состоит в следующем:*  
> 
> Для каждого нетерминала грамматики создается своя подпрограмма, носящая его имя.  Её задача - начиная с указанного места исходной цепочки найти подцепочку, которая выводится из этого нетерминала.  
> 
> Если такую подцепочку считать не удается, то подпрограмма завершает свою работу вызовом подпрограммы обработки ошибки, которая выдает сообщение о том, что цепочка не принадлежит языку, и останавливает разбор.  
> 
> Если подцепочку удалось найти, то работа подпрограммы считается нормально завершенной и осуществляется возврат в точку вызова.  
> 
> Тело каждой такой подпрограммы пишется непосредственно по правилам вывода соответствующего нетерминала:  
> - для правой части каждого правила осуществляется поиск подцепочки, выводимой из этой правой части;  
> - при этом терминалы распознаются самой подпрограммой, а нетерминалы соответствуют вызовам процедур, носящих их имена.
> 
> Результатом работы синтаксического анализатора обычно является некоторое промежуточное представление программы, однако, для А-языка мы можем, параллельно с синтаксическим анализом, вычислять значение выражения.
> 
> Операторы вычисления встраиваются непосредственно в подпрограммы нетерминалов. Необходимо также обратить внимание на то, что на данном этапе, помимо синтаксических ошибок, выявляются ошибки деления на нуль.
